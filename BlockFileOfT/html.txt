
					<t style="margin-left: 00px">uses BlockFileOfT;			</t>
				<br><t style="margin-left: 00px">uses System.Runtime.InteropServices;		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 00px">type		</t>
				<br><t style="margin-left: 10px">[StructLayout(LayoutKind.&Explicit)]			</t>
				<br><t style="margin-left: 10px">Str15 = record			</t>
				<br><t style="margin-left: 20px">private const MaxLength = 15;			</t>
				<br><t style="margin-left: 20px">//Я провёл много тестов чтоб убедится:			</t>
				<br><t style="margin-left: 20px">//-BinaryFormatter всегда делает для string заголовок в 25 байт			</t>
				<br><t style="margin-left: 20px">//-В разных случаях тело строки может сохранять как MaxLength*1, MaxLength*2 и MaxLength*3 байт.			</t>
				<br><t style="margin-left: 20px">//-Предыдущее зависит от того, на сколько редкие символы были использованы. Для более редких символов надо больше памяти			</t>
				<br><t style="margin-left: 20px">//Поэтому, на всякий случай, я сделал Size с расчётом на то, что все MaxLength символов могут быть редкими.			</t>
				<br><t style="margin-left: 20px">private const Size = 25 + MaxLength * 3;			</t>
				<br><t style="margin-left: 20px">private [FieldOffset(Size-1)] last: byte;			</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 20px">private class f := new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter;			</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 20px">public class function operator explicit(s: string): Str15;		</t>
				<br><t style="margin-left: 20px">begin		</t>
				<br><t style="margin-left: 30px">if s.Length > MaxLength then s := s.Substring(0, MaxLength);			</t>
				<br><t style="margin-left: 30px">var str := new System.IO.MemoryStream(Size);			</t>
				<br><t style="margin-left: 30px">str.SetLength(Size);			</t>
				<br><t style="margin-left: 30px">f.Serialize(str, s);			</t>
				<br><t style="margin-left: 30px">var a := str.ToArray;		</t>
				<br><t style="margin-left: 30px">var hnd := GCHandle.Alloc(a, GCHandleType.Pinned);		</t>
				<br><t style="margin-left: 30px">try		</t>
				<br><t style="margin-left: 40px">var ptr: ^Str15 := pointer(hnd.AddrOfPinnedObject);			</t>
				<br><t style="margin-left: 40px">Result := ptr^;			</t>
				<br><t style="margin-left: 30px">finally		</t>
				<br><t style="margin-left: 40px">hnd.Free;		</t>
				<br><t style="margin-left: 30px">end;		</t>
				<br><t style="margin-left: 20px">end;		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 20px">public class function operator explicit(s: Str15): string;		</t>
				<br><t style="margin-left: 20px">begin		</t>
				<br><t style="margin-left: 30px">var a := new byte[Size];			</t>
				<br><t style="margin-left: 30px">var hnd := GCHandle.Alloc(a, GCHandleType.Pinned);		</t>
				<br><t style="margin-left: 30px">try		</t>
				<br><t style="margin-left: 40px">var ptr: ^Str15 := pointer(hnd.AddrOfPinnedObject);			</t>
				<br><t style="margin-left: 40px">ptr^ := s;			</t>
				<br><t style="margin-left: 30px">finally		</t>
				<br><t style="margin-left: 40px">hnd.Free;		</t>
				<br><t style="margin-left: 30px">end;		</t>
				<br><t style="margin-left: 30px">var str := new System.IO.MemoryStream(a);			</t>
				<br><t style="margin-left: 30px">Result := string(f.Deserialize(str));			</t>
				<br><t style="margin-left: 20px">end;		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 10px">end;		</t>
				<br><t style="margin-left: 10px">r1 = record			</t>
				<br><t style="margin-left: 20px">public s: Str15;			</t>
				<br><t style="margin-left: 20px">public i: integer;			</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 20px">public constructor(s: string; i: integer);		</t>
				<br><t style="margin-left: 20px">begin		</t>
				<br><t style="margin-left: 30px">self.s := Str15(s);			</t>
				<br><t style="margin-left: 30px">self.i := i;			</t>
				<br><t style="margin-left: 20px">end;		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 20px">public function ToString: string; override :=			</t>
				<br><t style="margin-left: 20px">$'r1("{string(s)}", {i})';			</t>
				<br><t style="margin-left: 10px">end;		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 00px">begin		</t>
				<br><t style="margin-left: 10px">var f := new BlockFileOf&ltr1>('temp.bin');			</t>
				<br><t style="margin-left: 10px">var a1 := new r1('abcd', 1234);			</t>
				<br><t style="margin-left: 10px">var b1 := new r1('abcd' * 4, 5678);			</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 10px">{		</t>
				<br><t style="margin-left: 10px">f.Reset;			</t>
				<br><t style="margin-left: 10px">{}		</t>
				<br><t style="margin-left: 10px">f.Rewrite;			</t>
				<br><t style="margin-left: 10px">f.Write(a1, b1);			</t>
				<br><t style="margin-left: 10px">{}			</t>
				<br><t style="margin-left: 10px">f.Pos := 0;			</t>
				<br><t style="margin-left: 10px">var a2 := f.Read;			</t>
				<br><t style="margin-left: 10px">var b2 := f.Read;			</t>
				<br><t style="margin-left: 10px">f.Close;			</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 10px">writeln(a1);			</t>
				<br><t style="margin-left: 10px">writeln(b1);			</t>
				<br><t style="margin-left: 10px">writeln(string(a1.s).Length);			</t>
				<br><t style="margin-left: 10px">writeln(string(b1.s).Length);			</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 10px">writeln(a2);			</t>
				<br><t style="margin-left: 10px">writeln(b2);			</t>
				<br><t style="margin-left: 10px">writeln(string(a2.s).Length);			</t>
				<br><t style="margin-left: 10px">writeln(string(b2.s).Length);			</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 00px">end.		</t>
