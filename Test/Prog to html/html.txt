
					<t style="margin-left: 00px">uses BlockFileOfT;		</t>
				<br><t style="margin-left: 00px">uses System.Runtime.InteropServices;//Это пространство имён содержит несколько атрибутов, которые понадобятся		</t>
				<br><t style="margin-left: 180px">//Можно писать и на прямую "System.Runtime.InteropServices.FieldOffset", но это не очень удобно		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 00px">type		</t>
				<br><t style="margin-left: 10px">//Чтоб сделать ещё 1 тип строки - надо:		</t>
				<br><t style="margin-left: 10px">//  -Скопировать тип описаный ниже		</t>
				<br><t style="margin-left: 10px">//  -Поменять значение константы MaxLength на нужную длину		</t>
				<br><t style="margin-left: 10px">//  -Поменять число в названии (к примеру, Str15 на Str256)		</t>
				<br><t style="margin-left: 10px">//  -Поменять тип в операторах explicit (хотя, компилятор и не даст его оставить Str15)		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 10px">[StructLayout(LayoutKind.&Explicit)]		</t>
				<br><t style="margin-left: 10px">Str15=record		</t>
				<br><t style="margin-left: 20px">private const MaxLength = 15;		</t>
				<br><t style="margin-left: 20px">//Я провёл много тестов чтоб убедится:		</t>
				<br><t style="margin-left: 20px">//-BinaryFormatter всегда делает для string заголовок в 25 байт		</t>
				<br><t style="margin-left: 20px">//-В разных случаях тело строки может сохранять как MaxLength*1, MaxLength*2 и MaxLength*3 байт.		</t>
				<br><t style="margin-left: 20px">//Последнее зависит от того, какие редкие символы были использованы. Для более редких символов надо больше памяти		</t>
				<br><t style="margin-left: 20px">//Поэтому, на всякий случай, я сделал размер с расчётом на то, что все 15 символов могут быть редкими.		</t>
				<br><t style="margin-left: 20px">private const Size=25+MaxLength*3;		</t>
				<br><t style="margin-left: 20px">private [FieldOffset(Size-1)] last: byte;		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 20px">private class f := new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter;		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 20px">public class function operator explicit(s:string):Str15;		</t>
				<br><t style="margin-left: 20px">begin		</t>
				<br><t style="margin-left: 30px">if s.Length > MaxLength then s := s.Substring(0,MaxLength);		</t>
				<br><t style="margin-left: 30px">var str := new System.IO.MemoryStream(Size);		</t>
				<br><t style="margin-left: 30px">str.SetLength(Size);		</t>
				<br><t style="margin-left: 30px">f.Serialize(str, s);		</t>
				<br><t style="margin-left: 30px">var a := str.ToArray;		</t>
				<br><t style="margin-left: 30px">var ptr: ^Str15 := pointer(@a[0]);		</t>
				<br><t style="margin-left: 30px">Result := ptr^;		</t>
				<br><t style="margin-left: 20px">end;		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 20px">public class function operator explicit(s:Str15):string;		</t>
				<br><t style="margin-left: 20px">begin		</t>
				<br><t style="margin-left: 30px">var a := new byte[Size];		</t>
				<br><t style="margin-left: 30px">var ptr: ^Str15 := pointer(@a[0]);		</t>
				<br><t style="margin-left: 30px">ptr^ := s;		</t>
				<br><t style="margin-left: 30px">var str := new System.IO.MemoryStream(a);		</t>
				<br><t style="margin-left: 30px">Result := string(f.Deserialize(str));		</t>
				<br><t style="margin-left: 20px">end;		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 10px">end;		</t>
				<br><t style="margin-left: 10px">r1=record		</t>
				<br><t style="margin-left: 20px">public s: Str15;		</t>
				<br><t style="margin-left: 20px">public i: integer;		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 20px">public constructor(s:string; i: integer);		</t>
				<br><t style="margin-left: 20px">begin		</t>
				<br><t style="margin-left: 30px">self.s := Str15(s);		</t>
				<br><t style="margin-left: 30px">self.i := i;		</t>
				<br><t style="margin-left: 20px">end;		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 20px">public function ToString:string; override :=		</t>
				<br><t style="margin-left: 20px">$'r1("{string(s).Replace(#0,#32)}", {i})';		</t>
				<br><t style="margin-left: 10px">end;		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 00px">begin		</t>
				<br><t style="margin-left: 10px">var f := new BlockFileOf&ltr1>('temp.bin');		</t>
				<br><t style="margin-left: 10px">var a1 := new r1('abcd',1234);		</t>
				<br><t style="margin-left: 10px">var b1 := new r1('abcd'*4,5678);		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 10px">{		</t>
				<br><t style="margin-left: 10px">f.Reset;		</t>
				<br><t style="margin-left: 10px">{}		</t>
				<br><t style="margin-left: 10px">f.Rewrite;		</t>
				<br><t style="margin-left: 10px">f.Write(a1,b1);		</t>
				<br><t style="margin-left: 10px">{}		</t>
				<br><t style="margin-left: 10px">f.Pos := 0;		</t>
				<br><t style="margin-left: 10px">var a2 := f.Read;		</t>
				<br><t style="margin-left: 10px">var b2 := f.Read;		</t>
				<br><t style="margin-left: 10px">f.Close;		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 10px">writeln(a1);		</t>
				<br><t style="margin-left: 10px">writeln(b1);		</t>
				<br><t style="margin-left: 10px">writeln(string(a1.s).Length);		</t>
				<br><t style="margin-left: 10px">writeln(string(b1.s).Length);		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 10px">writeln(a2);		</t>
				<br><t style="margin-left: 10px">writeln(b2);		</t>
				<br><t style="margin-left: 10px">writeln(string(a2.s).Length);		</t>
				<br><t style="margin-left: 10px">writeln(string(b2.s).Length);		</t>
				<br><t style="margin-left: 00px">		</t>
				<br><t style="margin-left: 00px">end.		</t>
